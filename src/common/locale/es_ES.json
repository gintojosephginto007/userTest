{
  "any.unknown": "{{#label}} no está permitido(a)",
  "any.invalid": "{{#label}} contiene un valor inválido",
  "any.empty": "{{#label}} no debe estar vacío",
  "any.required": "{{#label}} es un campo obligatorio",
  "any.allowOnly": "{{#label}} sólo se permite estos valores {{#valids}}",
  "any.default": "tiró un error cuándo corriendo método por defecto",
  "any.failover": "threw an error when running failover method",
  "alternatives.base": "{{#label}} no coincide con ninguna de las alternativas permitidas",
  "alternatives.types": "{{#label}} debe ser uno de {{#types}}",
  "alternatives.match": "{{#label}} no coincide con ninguna de las alternativas permitidas",
  "array.base": "{{#label}} debe ser un array",
  "array.includes": "{{#label}} no coincide con ninguna de las alternativas permitidas",
  "array.includesRequiredUnknowns": "{{#label}} no contiene {{#unknownMisses}} valor (es) requerido(s)",
  "array.includesRequiredKnowns": "{{#label}} no contiene {{#knownMisses}}",
  "array.includesRequiredBoth": "{{#label}} no contiene {{#knownMisses}} y {{#unknownMisses}} otros valores requeridos",
  "array.excludes": "{{#label}} contiene un valor excluido",
  "array.hasKnown": "no contiene al menos una coincidencia requerida para el tipo \"{#patternLabel}\"",
  "array.hasUnknown": "{{#label}} no contiene al menos una coincidencia requerida",
  "array.min": "{{#label}} debe contener al menos {{#limit}} elementos",
  "array.max": "{{#label}} debe contener menos o igual a {{#limit}} elementos",
  "array.length": "{{#label}} debe contener {{#limit}} elementos",
  "array.orderedLength": "{{#label}} debe contener como máximo {{#limit}} elementos",
  "array.ref": "referencias \"{{#ref}}\" que no es un entero positivo",
  "array.sort": "debe ordenarse en {{#order}} orden por {{#by}}",
  "array.sort.mismatching": "no se puede ordenar debido a tipos no coincidentes",
  "array.sort.unsupported": "no se puede ordenar debido a que el tipo {{#type}} no es compatible",
  "array.sparse": "{{#label}} no debe ser un elemento de matriz disperso",
  "array.unique": "{{#label}} contiene un valor duplicado",
  "boolean.base": "{{#label}} debe ser un valor booleano",
  "binary.base": "{{#label}} debe ser una cadena o un buffer",
  "binary.min": "{{#label}} debe tener al menos {{#limit}} bytes",
  "binary.max": "{{#label}} debe ser menor o igual a {{#limit}} bytes",
  "binary.length": "{{#label}} debe ser {{#limit}} bytes",
  "binary.ref": "{{#label}} referencias \"{{#ref}}\" que no es un entero positivo",
  "date.base": "{{#label}} debe ser un número de milisegundos o fecha valida String",
  "date.strict": "{{#label}} debe ser una fecha valida",
  "date.min": "{{#label}} debe ser mayor que o igual a \"{{#limit}}\"",
  "date.max": "{{#label}} debe ser menor o igual a \"{{#limit}}\"",
  "date.less": "{{#label}} debe ser menor que \"{{#limit}}\"",
  "date.greater": "{{#label}} debe ser mayor que \"{{#limit}}\"",
  "date.isoDate": "{{#label}} debe ser una fecha ISO 8601 válida",
  "date.timestamp.javascript": "{{#label}}debe ser una marca de tiempo válida o una cantidad de milisegundos",
  "date.timestamp.unix": "{{#label}} debe ser una marca de tiempo válida o un número de segundos",
  "date.ref": "{{#label}} hace referencia a \"{{#ref}}\" que no es una fecha",
  "function.base": "{{#label}} debe ser una funcion",
  "function.arity": "{{#label}} debe haber un arity de {{#n}}",
  "function.class": "{{#label}} debe ser una clase",
  "function.maxArity": "{{#label}} debe haber un arity menor o igual a {{#n}}",
  "function.minArity": "{{#label}} debe haber un arity mayor o igual a {{#n}}",
  "lazy.base": "!!schema Error: lazy schema debe ser fijado",
  "lazy.schema": "!!schema Error: lazy schema función debe devolver un esquema",
  "object.base": "{{#label}} debe ser un objeto",
  "object.allowUnknown": "{{#label}} No se permite",
  "object.and": "contiene {{#presentWithLabels}} sin su necesaria pares {{#missingWithLabels}}",
  "object.assert": "!!\"{{#ref}}\" validacion falló porque \"{{#ref}}\" fallo al {{#message}}",
  "object.length": "{{#label}} debe tener {{#limit}} niños",
  "object.max": "{{#label}} debe haber menos de o igual a {{#limit}} niños",
  "object.min": "{{#label}} debe tener al menos {{#limit}} niños",
  "object.missing": "{{#label}} debe contener al menos uno de {{#peersWithLabels}}",
  "object.nand": "!!\"{{#mainWithLabel}}\" no debe existir simultáneamente con {{#peersWithLabels}}",
  "object.oxor": "contiene un conflicto entre exclusivo pares {{#peersWithLabels}}",
  "object.ref": "referencias \"{{#ref}}\" que no es un entero positivo",
  "object.refType": "{{#label}} debe ser una referencia de Joi",
  "object.rename.multiple": "no puede renombrar el niño \"{{#from}}\" porque múltiples renombra son discapacitados y otra llave ya fue cambiado a \"{{#to}}\"",
  "object.rename.override": "no puede renombrar el niño \"{{#from}}\" porque está desactivada y objetivo \"{{#to}}\" existe",
  "object.schema": "{{#label}} debe ser un esquema Joi de tipo {{#type}}",
  "object.type": "{{#label}} debe ser una instancia de \"{{#type}}\"",
  "object.with": "!!\"{{#mainWithLabel}}\" falta peer \"{{#peerWithLabel}}\"",
  "object.without": "!!\"{{#mainWithLabel}}\" conflicto con forbidden peer \"{{#peerWithLabel}}\"",
  "object.xor": "debe contener al menos uno de {{#peersWithLabels}}",
  "number.base": "{{#label}} tiene que ser un número",
  "number.unsafe": "{{#label}} debe ser un número seguro",
  "number.min": "{{#label}} debe ser mayor o igual a {{#limit}}",
  "number.max": "{{#label}} debe ser menor o igual a {{#limit}}",
  "number.less": "{{#label}} debe ser menor de {{#limit}}",
  "number.greater": "{{#label}} debe ser mayor de {{#limit}}",
  "number.integer": "{{#label}} debe ser un numero entero",
  "number.negative": "{{#label}} debe ser un numero negativo",
  "number.positive": "{{#label}} debe ser un numero posativo",
  "number.precision": "{{#label}} no debe tener más de {{#limit}} decimales",
  "number.ref": "{{#label}} referencias \"{{#ref}}\" que no es un número",
  "number.multiple": "{{#label}} debe ser un múltiplo de {{#multiple}}",
  "number.port": "{{#label}} debe ser un puerto válido",
  "string.base": "{{#label}} debe ser una cadena",
  "string.min": "{{#label}} debe tener al menos {{#limit}} caracteres",
  "string.max": "{{#label}} debe ser menor o igual a {{#limit}} caracteres",
  "string.length": "{{#label}} debe ser iqual a {{#limit}} caracteres",
  "string.alphanum": "{{#label}} sólo debe contener caracteres alfanuméricos",
  "string.token": "{{#label}} sólo debe contener caracteres alfanuméricos y subrayados",
  "string.regex.base": "con el valor \"{{.}}\" no coincide con el patrón requerido: {{#pattern}}",
  "string.regex.name": "con el valor \"{{.}}\" no coincide con el patrón {{#name}}",
  "string.regex.invert.base": "con el valor \"{{.}}\" coincide con el patrón invertido: {{#pattern}}",
  "string.regex.invert.name": "con el valor \"{{.}}\" coincide con el patrón invertido {{#name}}",
  "string.domain": "{{#label}} debe contener un nombre de dominio válido",
  "string.email": "{{#label}} debe ser un correo electrónico válido",
  "string.uri": "{{#label}} debe ser un URL válido",
  "string.uriRelativeOnly": "{{#label}} debe ser una URL relativa válida",
  "string.uriCustomScheme": "{{#label}} debe ser un URI válido con un esquema que coincida con el patrón {{#scheme}}",
  "string.isoDate": "{{#label}} debe ser una fecha valida ISO 8601",
  "string.isoDuration": "{{#label}} debe tener una duración ISO 8601 válida",
  "string.guid": "{{#label}} debe ser un valido GUID",
  "string.hex": "{{#label}} debe contener caracteres hexadecimales",
  "string.hexAlign": "representación hexadecimal byte decodificado deben estar alineados",
  "string.base64": "{{#label}} debe ser una cadena base64 válido",
  "string.dataUri": "{{#label}} debe ser una cadena de dataUri válida",
  "string.hostname": "{{#label}} debe ser un valido hostname",
  "string.normalize": "{{#label}} debe ser Unicode normalizado en la {{#form}} forma",
  "string.lowercase": "{{#label}} sólo debe contener caracteres en minúscula",
  "string.uppercase": "{{#label}} sólo debe contener caracteres en mayúsculas",
  "string.trim": "{{#label}} no debe haber dirigiendo o trailing whitespace",
  "string.creditCard": "{{#label}} debe ser el numero de una tarjeta de crédito",
  "string.ref": "referencias \"{{#ref}}\" que no es un número",
  "string.ip": "{{#label}} debe ser una dirección IP válida con un {{#cidr}} CIDR",
  "string.ipVersion": "{{#label}} debe ser una dirección IP válida de una de las siguientes versiones {{#version}} a {{#cidr}} CIDR",
  "symbol.base": "{{#label}} debe ser un símbolo",
  "symbol.map": "{{#label}} debe ser uno de {{#map}}",
  "string.pattern.base": "{{#label}}",
  "string.empty": "{{#label}} No se permite estar vacía",
  "any.only": "{{#label}} No se permite estar vacía"
}